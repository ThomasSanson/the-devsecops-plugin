---
version: "3"

vars:
  TASK_DOCKER_CE_ENABLED: '{{.TASK_DOCKER_CE_ENABLED | default "true"}}'
  TASK_DOCKER_CE_VENV_DIR: '{{.TASK_DOCKER_CE_VENV_DIR | default "./venv/docker-ce"}}'
  TASK_DOCKER_CE_ANSIBLE_CMD: '{{.TASK_DOCKER_CE_ANSIBLE_CMD | default "./venv/docker-ce/bin/ansible-playbook"}}'
  TASK_DOCKER_CE_ANSIBLE_GALAXY_CMD: '{{.TASK_DOCKER_CE_ANSIBLE_GALAXY_CMD | default "./venv/docker-ce/bin/ansible-galaxy"}}'
  TASK_DOCKER_CE_ANSIBLE_REQUIREMENTS_FILE: '{{.TASK_DOCKER_CE_ANSIBLE_REQUIREMENTS_FILE | default ".config/docker-ce/requirements.txt"}}'
  TASK_DOCKER_CE_ANSIBLE_ROLES_REQUIREMENTS: '{{.TASK_DOCKER_CE_ANSIBLE_ROLES_REQUIREMENTS | default ".config/docker-ce/requirements.yml"}}'
  TASK_DOCKER_CE_ANSIBLE_PLAYBOOK_FILE: '{{.TASK_DOCKER_CE_ANSIBLE_PLAYBOOK_FILE | default ".config/docker-ce/playbook.yml"}}'
  TASK_DOCKER_CE_PYTHON_VERSION_FILE: '{{.TASK_DOCKER_CE_PYTHON_VERSION_FILE | default ".config/python/.python-version"}}'
  TASK_DOCKER_CE_ANSIBLE_INVENTORY_TARGET: "localhost" # DevSkim: ignore DS162092

  # Authentication settings
  TASK_DOCKER_CE_AUTH_ENABLED: '{{.TASK_DOCKER_CE_AUTH_ENABLED | default "false"}}'
  TASK_DOCKER_CE_REGISTRY_USERNAME: '{{.TASK_DOCKER_CE_REGISTRY_USERNAME | default ""}}'
  TASK_DOCKER_CE_REGISTRY_PASSWORD: '{{.TASK_DOCKER_CE_REGISTRY_PASSWORD | default ""}}'
  TASK_DOCKER_CE_REGISTRY_URL: '{{.TASK_DOCKER_CE_REGISTRY_URL | default ""}}'

  # Build settings
  TASK_DOCKER_CE_IMAGE_NAME: '{{.TASK_DOCKER_CE_IMAGE_NAME | default "test"}}'
  TASK_DOCKER_CE_IMAGE_TAG:
    sh: |
      if [ -n "${TASK_DOCKER_CE_IMAGE_TAG:-}" ]; then
        echo "${TASK_DOCKER_CE_IMAGE_TAG}"
      elif [ -f "VERSION" ]; then
        echo $(cat VERSION)
      else
        echo "latest"
      fi
  TASK_DOCKER_CE_DOCKERFILE: '{{.TASK_DOCKER_CE_DOCKERFILE | default ""}}'
  TASK_DOCKER_CE_CONTEXT: '{{.TASK_DOCKER_CE_CONTEXT | default "."}}'
  TASK_DOCKER_CE_PUSH:
    sh: |
      if [ -n "${TASK_DOCKER_CE_PUSH:-}" ]; then
        echo "${TASK_DOCKER_CE_PUSH}"
      elif [[ "{{.TASK_DEVSECOPS_RELEASE_CURRENT_BRANCH}}" == "{{.TASK_DEVSECOPS_RELEASE_DEFAULT_BRANCH}}" ]]; then
        echo "true"
        exit 0
      else
        echo "false"
      fi
  TASK_DOCKER_CE_BUILD_RUN: '{{.TASK_DOCKER_CE_BUILD_RUN | default "always"}}'

  # BuildKit settings
  TASK_DOCKER_CE_BUILDKIT_ENABLED: '{{.TASK_DOCKER_CE_BUILDKIT_ENABLED | default "true"}}'
  TASK_DOCKER_CE_BUILDKIT_CACHE_TYPE: '{{.TASK_DOCKER_CE_BUILDKIT_CACHE_TYPE | default "inline"}}' # Options: inline, local, registry, none
  TASK_DOCKER_CE_BUILDKIT_CACHE_PATH: '{{.TASK_DOCKER_CE_BUILDKIT_CACHE_PATH | default ".cache/docker/buildkit"}}'
  TASK_DOCKER_CE_BUILDKIT_CACHE_MAX_DAYS: '{{.TASK_DOCKER_CE_BUILDKIT_CACHE_MAX_DAYS | default "7"}}'
  TASK_DOCKER_CE_BUILDKIT_PLATFORM: '{{.TASK_DOCKER_CE_BUILDKIT_PLATFORM | default ""}}'

  # Labels (optional)
  TASK_DOCKER_CE_CUSTOM_LABELS: '{{.TASK_DOCKER_CE_CUSTOM_LABELS | default ""}}'
  TASK_DOCKER_CE_BASE_LABELS: >
    --label org.opencontainers.image.source={{.REPO_URL | default "local"}}

  # Save settings
  TASK_DOCKER_CE_SAVE_DIR: '{{.TASK_DOCKER_CE_SAVE_DIR | default ".cache/docker/images"}}'
  TASK_DOCKER_CE_SAVE_ENABLED: '{{.TASK_DOCKER_CE_SAVE_ENABLED | default "false"}}'
  TASK_DOCKER_CE_SAVE_COMPRESS: '{{.TASK_DOCKER_CE_SAVE_COMPRESS | default "1"}}'
  TASK_DOCKER_CE_SAVE_RUN: '{{.TASK_DOCKER_CE_SAVE_RUN | default "always"}}'

env:
  LANG: "C.UTF-8"
  LC_ALL: "C.UTF-8"
  LANGUAGE: "C.UTF-8"
  ANSIBLE_ROLES_PATH: ".config/docker-ce/roles"
  DOCKER_BUILDKIT: "{{.TASK_DOCKER_CE_BUILDKIT_ENABLED}}"

tasks:
  install:dependencies:
    desc: |
      ‚ÑπÔ∏è Description:
        Sets up Ansible and its dependencies in a dedicated virtual environment

      üîß Variables:
        - TASK_DOCKER_CE_VENV_DIR: Virtual environment location
        - TASK_DOCKER_CE_ANSIBLE_REQUIREMENTS_FILE: Dependencies file path

      üîê Preconditions:
        - Python 3.x must be installed
        - Internet connectivity required

      üîÑ Execution:
        Creates virtualenv and installs required packages
    status:
      - test "{{.TASK_DOCKER_CE_ENABLED}}" = "false"
    preconditions:
      - sh: "command -v python3 >/dev/null 2>&1"
        msg: "‚ùå Python 3 is not installed"
      - sh: "test -f {{.TASK_DOCKER_CE_PYTHON_VERSION_FILE}}"
        msg: "‚ùå Python version file not found at {{.TASK_DOCKER_CE_PYTHON_VERSION_FILE}}"
      - sh: "test -f {{.TASK_DOCKER_CE_ANSIBLE_REQUIREMENTS_FILE}}"
        msg: "‚ùå Requirements file not found at {{.TASK_DOCKER_CE_ANSIBLE_REQUIREMENTS_FILE}}"
    cmds:
      - cmd: echo "üîÑ Starting install dependencies phase"
        silent: true
      - defer: { task: cleanup }
      - python$(cut -d '=' -f 2 {{.TASK_DOCKER_CE_PYTHON_VERSION_FILE}}) -m venv {{.TASK_DOCKER_CE_VENV_DIR}}
      - "{{.TASK_DOCKER_CE_VENV_DIR}}/bin/pip install -r {{.TASK_DOCKER_CE_ANSIBLE_REQUIREMENTS_FILE}}"
      - cmd: echo "üéâ Install dependencies phase completed successfully"
        silent: true

  install:roles:
    desc: |
      ‚ÑπÔ∏è Description:
        Installs required Ansible roles

      üîß Variables:
        - TASK_DOCKER_CE_ANSIBLE_GALAXY_CMD: Ansible Galaxy command path
        - TASK_DOCKER_CE_ANSIBLE_ROLES_REQUIREMENTS: Roles requirements file path

      üîê Preconditions:
        - Dependencies must be installed

      üîÑ Execution:
        Installs required Ansible roles
    status:
      - test "{{.TASK_DOCKER_CE_ENABLED}}" = "false"
    deps: [install:dependencies]
    preconditions:
      - sh: "test -f {{.TASK_DOCKER_CE_ANSIBLE_ROLES_REQUIREMENTS}}"
        msg: "‚ùå Roles requirements file not found at {{.TASK_DOCKER_CE_ANSIBLE_ROLES_REQUIREMENTS}}"
    cmds:
      - cmd: echo "üîÑ Starting install roles phase"
        silent: true
      - mkdir -p .config/docker-ce/roles
      - "{{.TASK_DOCKER_CE_ANSIBLE_GALAXY_CMD}} install -r {{.TASK_DOCKER_CE_ANSIBLE_ROLES_REQUIREMENTS}} --roles-path .config/docker-ce/roles"
      - "{{.TASK_DOCKER_CE_ANSIBLE_GALAXY_CMD}} collection install -r {{.TASK_DOCKER_CE_ANSIBLE_ROLES_REQUIREMENTS}}"
      - cmd: echo "üéâ Install roles phase completed successfully"
        silent: true

  install:
    desc: |
      ‚ÑπÔ∏è Description:
        Installs Docker-CE using Ansible automation

      üîß Variables:
        - TASK_DOCKER_CE_ANSIBLE_CMD: Ansible command path
        - TASK_DOCKER_CE_ANSIBLE_PLAYBOOK_FILE: Ansible playbook location

      üîê Preconditions:
        - Dependencies must be installed
        - Roles must be installed

      üîÑ Execution:
        Runs Ansible playbook for Docker-CE installation
    status:
      - command -v docker &> /dev/null
    preconditions:
      - sh: "test -f {{.TASK_DOCKER_CE_ANSIBLE_PLAYBOOK_FILE}}"
        msg: "‚ùå Playbook file not found at {{.TASK_DOCKER_CE_ANSIBLE_PLAYBOOK_FILE}}"
    cmds:
      - cmd: echo "üîÑ Starting docker-ce installation phase"
        silent: true
      - defer: { task: cleanup }
      - task: install:roles
      - |
        {{.TASK_DOCKER_CE_ANSIBLE_CMD}} \
          -i {{.TASK_DOCKER_CE_ANSIBLE_INVENTORY_TARGET}}, \
          -c local \
          {{.TASK_DOCKER_CE_ANSIBLE_PLAYBOOK_FILE}} \
          -e 'ansible_python_interpreter=/usr/bin/python3'
      - cmd: echo "üéâ Docker-ce installation phase completed successfully"
        silent: true

  cleanup:
    desc: |
      ‚ÑπÔ∏è Description:
        Performs cleanup of temporary files and failed installations

      üîß Variables:
        - TASK_DOCKER_CE_VENV_DIR: Virtual environment to clean

      üîê Preconditions: None

      üîÑ Execution:
        Removes temporary files and partial installations
    internal: true
    status:
      - test "{{.TASK_DOCKER_CE_ENABLED}}" = "false"
    cmds:
      - cmd: echo "üîÑ Starting cleanup phase"
        silent: true
      - rm -rf {{.TASK_DOCKER_CE_VENV_DIR}}/*.tmp
      - rm -rf {{.TASK_DOCKER_CE_VENV_DIR}}/*.log
      - cmd: echo "üéâ Cleanup phase completed successfully"
        silent: true

  build:all:dockerfile:
    desc: Build all Dockerfiles in the project.
    summary: |
      ‚ÑπÔ∏è Description:
        Searches for all Dockerfile in the project and attempts to build them.
        This task ensures that all Docker builds are functioning correctly.

      üîß Variables:
        DOCKERFILE_LIST: A list of all Dockerfile found in the project, excluding gitignored paths.

      üîê Preconditions:
        - Docker must be installed and running.
        - sha256sum must be installed.
        - git must be installed.

      üîÑ Execution:
        Iterates through each Dockerfile found and attempts to build it.

      üìù Note:
        This task is useful for verifying the integrity of all Dockerfile
        in the project. It does not push or deploy the built images.
    vars:
      DOCKERFILE_LIST:
        sh: git ls-files -c -o --exclude-standard | grep Dockerfile || true
    preconditions:
      - sh: command -v docker >/dev/null 2>&1
        msg: "‚ùå Docker is not installed or not in PATH. Please install Docker first."
      - sh: command -v sha256sum >/dev/null 2>&1
        msg: "‚ùå sha256sum is not installed or not in PATH. Please install sha256sum first."
      - sh: command -v git >/dev/null 2>&1
        msg: "‚ùå git is not installed or not in PATH. Please install git first."
    status:
      - test "{{.TASK_DOCKER_CE_ENABLED}}" = "false"
    cmds:
      - cmd: echo "üîÑ Starting build all dockerfiles phase"
        silent: true
      - defer: { task: cleanup }
      - for: { var: DOCKERFILE_LIST }
        cmd: |
          echo "Building Dockerfile: {{.ITEM}}"
          HASH=$(sha256sum {{.ITEM}} | cut -d' ' -f1)
          docker build -t test-build-${HASH} -f {{.ITEM}} .
      - cmd: echo "üéâ Build all dockerfiles phase completed successfully"
        silent: true

  build:
    desc: |
      ‚ÑπÔ∏è Description:
        Build a Docker image using Docker CE

      üîß Variables:
        - TASK_DOCKER_CE_IMAGE_NAME: Name for the built image
        - TASK_DOCKER_CE_IMAGE_TAG: Tag for the built image
        - TASK_DOCKER_CE_DOCKERFILE: Path to Dockerfile
        - TASK_DOCKER_CE_CUSTOM_LABELS: Additional custom labels
    run: "{{.TASK_DOCKER_CE_BUILD_RUN}}"
    status:
      - test "{{.TASK_DOCKER_CE_ENABLED}}" = "false"
    cmds:
      - cmd: echo "üîÑ Starting build phase"
        silent: true
      - |
        echo "Building Docker image..."
        DOCKER_ARGS=""

        # Setup BuildKit cache options if enabled
        if [ "{{.TASK_DOCKER_CE_BUILDKIT_ENABLED}}" = "true" ]; then
          echo "üîß BuildKit is enabled"

          # Configure cache based on the specified type
          case "{{.TASK_DOCKER_CE_BUILDKIT_CACHE_TYPE}}" in
            "local")
              # Verify if local cache is supported by checking Docker info
              if docker info --format '{{.Driver}}' | grep -q 'containerd\|moby'; then
                mkdir -p "{{.TASK_DOCKER_CE_BUILDKIT_CACHE_PATH}}"
                echo "üì¶ Using BuildKit local cache directory: {{.TASK_DOCKER_CE_BUILDKIT_CACHE_PATH}}"

                # Clean old cache files if max days is set
                if [ -n "{{.TASK_DOCKER_CE_BUILDKIT_CACHE_MAX_DAYS}}" ] && [ "{{.TASK_DOCKER_CE_BUILDKIT_CACHE_MAX_DAYS}}" != "0" ]; then
                  echo "üßπ Cleaning cache files older than {{.TASK_DOCKER_CE_BUILDKIT_CACHE_MAX_DAYS}} days"
                  find "{{.TASK_DOCKER_CE_BUILDKIT_CACHE_PATH}}" -type f -mtime +{{.TASK_DOCKER_CE_BUILDKIT_CACHE_MAX_DAYS}} -delete 2>/dev/null || true
                fi

                # Add cache options
                DOCKER_ARGS="$DOCKER_ARGS --cache-from type=local,src={{.TASK_DOCKER_CE_BUILDKIT_CACHE_PATH}} --cache-to type=local,dest={{.TASK_DOCKER_CE_BUILDKIT_CACHE_PATH}},mode=max"
              else
                echo "‚ö†Ô∏è Local cache not supported with current Docker driver. Falling back to inline cache."
                DOCKER_ARGS="$DOCKER_ARGS --build-arg BUILDKIT_INLINE_CACHE=1"
              fi
              ;;

            "inline")
              echo "üì¶ Using BuildKit inline cache"
              DOCKER_ARGS="$DOCKER_ARGS --build-arg BUILDKIT_INLINE_CACHE=1"
              ;;

            "registry")
              echo "üì¶ Using BuildKit registry cache"
              if [ -n "{{.TASK_DOCKER_CE_REGISTRY_URL}}" ]; then
                # Prepare the complete cache image name
                CACHE_IMAGE="{{.TASK_DOCKER_CE_IMAGE_NAME}}"

                # If in GitLab CI, use CI variables to build the cache image name
                if [ -n "${CI_REGISTRY_IMAGE}" ]; then
                  # Use GitLab CI registry image as cache
                  CACHE_IMAGE="${CI_REGISTRY_IMAGE}/cache/$(basename {{.TASK_DOCKER_CE_IMAGE_NAME}})"
                  echo "üîß GitLab CI detected, using registry cache: $CACHE_IMAGE"
                elif [[ "{{.TASK_DOCKER_CE_REGISTRY_URL}}" != */ ]]; then
                  # Add a slash if needed at the end of the registry URL
                  CACHE_IMAGE="{{.TASK_DOCKER_CE_REGISTRY_URL}}/$CACHE_IMAGE"
                else
                  CACHE_IMAGE="{{.TASK_DOCKER_CE_REGISTRY_URL}}$CACHE_IMAGE"
                fi

                # Try to download existing cache image
                echo "üì• Attempting to retrieve cache from $CACHE_IMAGE:cache"
                docker pull "$CACHE_IMAGE:cache" || echo "‚ö†Ô∏è No existing cache found, building a new cache"

                # Configure cache arguments
                DOCKER_ARGS="$DOCKER_ARGS --cache-from $CACHE_IMAGE:cache --build-arg BUILDKIT_INLINE_CACHE=1"

                # Store the cache image name for later use in push
                export DOCKER_CACHE_IMAGE="$CACHE_IMAGE"
              else
                echo "‚ö†Ô∏è Registry URL not configured. Falling back to inline cache."
                DOCKER_ARGS="$DOCKER_ARGS --build-arg BUILDKIT_INLINE_CACHE=1"
              fi
              ;;

            "none")
              echo "üì¶ BuildKit cache disabled"
              ;;

            *)
              echo "‚ö†Ô∏è Unknown cache type '{{.TASK_DOCKER_CE_BUILDKIT_CACHE_TYPE}}', using inline cache"
              DOCKER_ARGS="$DOCKER_ARGS --build-arg BUILDKIT_INLINE_CACHE=1"
              ;;
          esac

          # Add platform if specified
          if [ -n "{{.TASK_DOCKER_CE_BUILDKIT_PLATFORM}}" ]; then
            DOCKER_ARGS="$DOCKER_ARGS --platform={{.TASK_DOCKER_CE_BUILDKIT_PLATFORM}}"
          fi
        fi

        if [ -n "{{.TASK_DOCKER_CE_CUSTOM_LABELS}}" ]; then
          DOCKER_ARGS="$DOCKER_ARGS {{.TASK_DOCKER_CE_BASE_LABELS}} {{.TASK_DOCKER_CE_CUSTOM_LABELS}}"
        fi

        docker build \
          -t {{.TASK_DOCKER_CE_IMAGE_NAME}}:{{.TASK_DOCKER_CE_IMAGE_TAG}} \
          -f {{.TASK_DOCKER_CE_DOCKERFILE}} \
          $DOCKER_ARGS \
          {{.TASK_DOCKER_CE_CONTEXT}}
      - task: save
        vars:
          TASK_DOCKER_CE_IMAGE_NAME: "{{.TASK_DOCKER_CE_IMAGE_NAME}}"
          TASK_DOCKER_CE_IMAGE_TAG: "{{.TASK_DOCKER_CE_IMAGE_TAG}}"
          TASK_DOCKER_CE_SAVE_DIR: "{{.TASK_DOCKER_CE_SAVE_DIR}}"
          TASK_DOCKER_CE_SAVE_ENABLED: "{{.TASK_DOCKER_CE_SAVE_ENABLED}}"
          TASK_DOCKER_CE_SAVE_COMPRESS: "{{.TASK_DOCKER_CE_SAVE_COMPRESS}}"
          TASK_DOCKER_CE_SAVE_RUN: "{{.TASK_DOCKER_CE_SAVE_RUN}}"
      - cmd: echo "üéâ Build phase completed successfully"
        silent: true

  save:
    desc: |
      ‚ÑπÔ∏è Description:
        Save a Docker image to a local cache directory

      üîß Variables:
        - TASK_DOCKER_CE_IMAGE_NAME: Name of the image to save
        - TASK_DOCKER_CE_IMAGE_TAG: Tag of the image to save
        - TASK_DOCKER_CE_SAVE_DIR: Directory to store saved images
        - TASK_DOCKER_CE_SAVE_ENABLED: Enable image saving
        - TASK_DOCKER_CE_SAVE_COMPRESS: Compression level for saved images
    run: "{{.TASK_DOCKER_CE_SAVE_RUN}}"
    vars:
      IMAGE_NAME_SAFE:
        sh: echo "{{.TASK_DOCKER_CE_IMAGE_NAME}}" | tr '/:' '__'
    status:
      - test "{{.TASK_DOCKER_CE_SAVE_ENABLED}}" = "false"
    cmds:
      - cmd: echo "üîÑ Starting save phase"
        silent: true
      - |
        echo "Saving Docker image to {{.TASK_DOCKER_CE_SAVE_DIR}}..."
        mkdir -p {{.TASK_DOCKER_CE_SAVE_DIR}}

        # Generate a safe filename
        ARCHIVE_PATH="{{.TASK_DOCKER_CE_SAVE_DIR}}/{{.IMAGE_NAME_SAFE}}_{{.TASK_DOCKER_CE_IMAGE_TAG}}.tar.gz"

        # Save the image to cache
        echo "Saving image {{.TASK_DOCKER_CE_IMAGE_NAME}}:{{.TASK_DOCKER_CE_IMAGE_TAG}} to ${ARCHIVE_PATH}..."
        docker save {{.TASK_DOCKER_CE_IMAGE_NAME}}:{{.TASK_DOCKER_CE_IMAGE_TAG}} | gzip -{{.TASK_DOCKER_CE_SAVE_COMPRESS}} > "${ARCHIVE_PATH}"

        if [ $? -eq 0 ]; then
          echo "‚úÖ Image successfully saved to ${ARCHIVE_PATH}"
          echo "Image archive size: $(du -h "${ARCHIVE_PATH}" | cut -f1)"
        else
          echo "‚ùå Failed to save image"
          exit 1
        fi
      - cmd: echo "üéâ Save phase completed successfully"
        silent: true

  push:
    desc: |
      ‚ÑπÔ∏è Description:
        Push a Docker image to registry using Docker CE

      üîß Variables:
        - TASK_DOCKER_CE_PUSH: Enable push to registry
        - TASK_DOCKER_CE_AUTH_ENABLED: Enable registry authentication
        - TASK_DOCKER_CE_REGISTRY_URL: Registry URL
        - TASK_DOCKER_CE_REGISTRY_USERNAME: Registry username
        - TASK_DOCKER_CE_REGISTRY_PASSWORD: Registry password
        - TASK_DOCKER_CE_BUILDKIT_CACHE_TYPE: BuildKit cache type to use
    status:
      - test "{{.TASK_DOCKER_CE_ENABLED}}" = "false"
    cmds:
      - cmd: echo "üîÑ Starting push phase"
        silent: true
      - |
        if [ "{{.TASK_DOCKER_CE_PUSH}}" = "true" ]; then
          if [ "{{.TASK_DOCKER_CE_AUTH_ENABLED}}" = "true" ]; then
            echo "üîë Logging in to Docker registry..."
            echo "{{.TASK_DOCKER_CE_REGISTRY_PASSWORD}}" | docker login {{.TASK_DOCKER_CE_REGISTRY_URL}} \
              --username {{.TASK_DOCKER_CE_REGISTRY_USERNAME}} \
              --password-stdin
          fi

          echo "üì§ Pushing Docker image {{.TASK_DOCKER_CE_IMAGE_NAME}}:{{.TASK_DOCKER_CE_IMAGE_TAG}}..."
          docker push {{.TASK_DOCKER_CE_IMAGE_NAME}}:{{.TASK_DOCKER_CE_IMAGE_TAG}}

          # If using registry cache, also push the cache image
          if [ "{{.TASK_DOCKER_CE_BUILDKIT_CACHE_TYPE}}" = "registry" ] && [ -n "${DOCKER_CACHE_IMAGE}" ]; then
            echo "üì¶ Creating and pushing cache image ${DOCKER_CACHE_IMAGE}:cache"

            # Tag the current image as cache image
            docker tag {{.TASK_DOCKER_CE_IMAGE_NAME}}:{{.TASK_DOCKER_CE_IMAGE_TAG}} "${DOCKER_CACHE_IMAGE}:cache"

            # Push the cache image to the registry
            docker push "${DOCKER_CACHE_IMAGE}:cache"

            echo "‚úÖ Cache successfully pushed to ${DOCKER_CACHE_IMAGE}:cache"
          fi

          if [ "{{.TASK_DOCKER_CE_AUTH_ENABLED}}" = "true" ]; then
            docker logout {{.TASK_DOCKER_CE_REGISTRY_URL}}
          fi
        else
          echo "‚è© Skipping push (TASK_DOCKER_CE_PUSH is not true)"
        fi
      - cmd: echo "üéâ Push phase completed successfully"
        silent: true
